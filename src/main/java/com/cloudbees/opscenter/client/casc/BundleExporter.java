package com.cloudbees.opscenter.client.casc;

import com.cloudbees.jenkins.cjp.installmanager.casc.ConfigurationBundle;
import com.cloudbees.jenkins.cjp.installmanager.casc.ConfigurationBundleManager;
import com.cloudbees.jenkins.cjp.installmanager.casc.InvalidBundleException;
import com.cloudbees.jenkins.cjp.installmanager.casc.plugin.management.PluginInstallConfiguration;
import com.cloudbees.jenkins.plugins.assurance.CloudBeesAssurance;
import com.cloudbees.jenkins.plugins.assurance.model.Beekeeper;
import com.cloudbees.jenkins.plugins.assurance.remote.BeekeeperRemote;
import com.cloudbees.jenkins.plugins.assurance.remote.Status;
import com.cloudbees.jenkins.plugins.assurance.remote.extensionparser.Configuration;
import com.cloudbees.jenkins.plugins.assurance.remote.extensionparser.ParsedEnvelopeExtension;
import com.cloudbees.jenkins.plugins.assurance.remote.extensionparser.PluginConfiguration;
import com.cloudbees.jenkins.plugins.casc.YamlClientUtils;
import com.cloudbees.jenkins.plugins.casc.items.Items;
import com.cloudbees.jenkins.plugins.casc.rbac.GlobalRbac;
import com.cloudbees.jenkins.plugins.updates.envelope.EnvelopePlugin;
import com.cloudbees.jenkins.plugins.updates.envelope.Scope;

import edu.umd.cs.findbugs.annotations.CheckForNull;
import edu.umd.cs.findbugs.annotations.NonNull;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;

import hudson.Extension;
import hudson.ExtensionList;
import hudson.ExtensionPoint;
import hudson.PluginWrapper;
import jenkins.model.Jenkins;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang.StringUtils;
import org.kohsuke.accmod.Restricted;
import org.kohsuke.accmod.restrictions.NoExternalUse;
import org.kohsuke.accmod.restrictions.suppressions.SuppressRestrictedWarnings;
import org.yaml.snakeyaml.DumperOptions;
import org.yaml.snakeyaml.Yaml;

import javax.annotation.Nonnull;
import java.io.IOException;
import java.io.InputStream;
import java.io.StringWriter;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Collectors;

/**
 * Exporter for each CasC bundle file and section.
 */
@Restricted(NoExternalUse.class)
public abstract class BundleExporter implements ExtensionPoint {

    private static final Logger LOG = Logger.getLogger(BundleExporter.class.getName());

    /**
     * @return true if the RootAction is enabled so it can be displayed in UI
     */
    public boolean enabled() {
        return true;
    }

    /**
     * @return the yaml file this extension is exporting
     */
    @NonNull
    public abstract String getYamlFile();

    /**
     * @return the exported file as a String or null
     */
    @CheckForNull
    public abstract String getExport();

    /**
     * @return Description in the UI
     */
    @NonNull
    public abstract String getDescription();

    /**
     * @return section where to add the yaml file in the descriptor
     */
    @CheckForNull
    public abstract String getSection();

    /**
     * Return the exporter for a concrete yaml file
     * @param yamlFile the yaml file to export
     * @return The exporter or null if that exporter does not exist
     */
    @CheckForNull
    public static BundleExporter forYamlFile(@NonNull String yamlFile) {
        return ExtensionList.lookup(BundleExporter.class).stream().filter(exporter -> exporter.getYamlFile().equals(yamlFile) && exporter.enabled()).findFirst().orElse(null);
    }

    public static List<BundleExporter> all() {
        return ExtensionList.lookup(BundleExporter.class).stream().filter(exporter -> exporter.enabled()).collect(Collectors.toList());
    }


    /**
     * Exporter of the bundle.yaml file.
     */
    @Extension(ordinal = 6)
    public static final class DescriptorExporter extends BundleExporter {

        @NonNull
        @Override
        public String getYamlFile() {
            return "bundle.yaml";
        }

        @Override
        @CheckForNull
        public String getExport() {
            return descriptorFromTemplate(getInstanceName(), "Autogenerated bundle descriptor");
        }

        @NonNull
        @Override
        public String getDescription() {
            return "The bundle descriptor";
        }

        @Override
        public String getSection() {
            return null;
        }

        private String descriptorFromTemplate(@CheckForNull String bundleID, String description) {
            try (InputStream in = BundleExporter.class.getResourceAsStream("bundle-descriptor.yaml")){
                String bundle = IOUtils.toString(in, StandardCharsets.UTF_8);
                for (String section : getSections()) {
                    bundle = bundle.concat(String.format("%s:%n", section));
                    for(BundleExporter exporter : forSection(section)) {
                        bundle = bundle.concat(String.format("  - \"%s\"%n", exporter.getYamlFile()));
                    }
                }
                String apiVersion = StringUtils.defaultIfBlank(ConfigurationBundleManager.get().getConfigurationBundle().getApiVersion(), "1");
                return bundle.replace("%BUNDLE_ID%", bundleID != null ? bundleID : "jenkins").replace("%DESCRIPTION%", description).replace("%APIVERSION%", apiVersion);
            } catch (IOException e) {
                LOG.log(Level.WARNING, "Cannot read bundle descriptor template to generate an export response", e);
                return null;
            }
        }

        private List<BundleExporter> forSection(String section) {
            return BundleExporter.all().stream().filter(exporter -> exporter.getSection() != null && exporter.getSection().equals(section)).collect(Collectors.toList());
        }

        private List<String> getSections() {
            return BundleExporter.all().stream().filter(exporter -> exporter.getSection() != null).map(BundleExporter::getSection).collect(Collectors.toList());
        }

    }

    /**
     * Exporter of the plugins.yaml file as text.
     */
    @Extension(ordinal = 4)
    public static final class PluginsExporter extends BundleExporter {

        @NonNull
        @Override
        public String getYamlFile() {
            return "plugins.yaml";
        }

        /**
         * Generates the plugins.yaml file content.
         * <p>
         * The plugins list will contain all plugins installed in the controller, if and only if CAP is enabled.
         * It returns a warning message otherwise.
         */
        @SuppressRestrictedWarnings(value = {CloudBeesAssurance.class, ParsedEnvelopeExtension.class, Beekeeper.class,
                Configuration.class, PluginConfiguration.class})
        @Override
        @CheckForNull
        public String getExport() {
            // check if the CAP is enabled
            Status status = BeekeeperRemote.get().getStatus();
            if (!status.isCap()) {
                String msg = "# Cannot export plugins because CAP is not enabled";
                LOG.log(Level.WARNING, msg);
                return msg;
            }
            String apiVersion = StringUtils.defaultIfBlank(ConfigurationBundleManager.get().getConfigurationBundle().getApiVersion(), "1");
            if ("1".equals(apiVersion)) {
                return exportForApiVersion1();
            } else if ("2".equals(apiVersion)) {
                return exportForApiVersion2();
            } else {
                return "# Unsupported apiVersion " + apiVersion + ". This is a simple export of the installed plugins\n" + exportForApiVersion1();
            }
        }

        @SuppressRestrictedWarnings({CloudBeesAssurance.class, Beekeeper.class})
        @SuppressFBWarnings(value = "NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE", justification = "False positive. currentBundle.getPluginConfigurations() is already checked")
        private String exportForApiVersion2() {
            ConfigurationBundle currentBundle = ConfigurationBundleManager.get().getConfigurationBundle();

            if (currentBundle.getPluginConfigurations() == null || currentBundle.getPluginConfigurations().isEmpty()) {
                // Nothing coming from the plugins.yaml files, so we only can consider that those plugins can be installed from the UC
                // Those manually installed uploading the hpi file might fail
                return "# Those plugins manually installed (not using a CasC bundle) might not be installable using the exported CasC bundle if they were uploaded instead of installed through the Plugin Manager\n" +
                       exportForApiVersion1();
            }

            List<PluginWrapper> installedPlugins = Jenkins.get().getPluginManager().getPlugins();
            Set<String> allDependencies = installedPlugins.stream().flatMap(plugin -> plugin.getDependencies().stream()).map(dependency -> dependency.shortName).collect(Collectors.toSet());

            // First export those plugins that remains installed (not manually removed) which were installed using the CasC Bundle
            Set<String> installedByIds = installedPlugins.stream().map(PluginWrapper::getShortName).collect(Collectors.toSet());
            Set<PluginInstallConfiguration> confWithInstalledPlugins = currentBundle.getPluginConfigurations().stream().filter(conf -> CollectionUtils.containsAny(conf.getDefinedPlugins(), installedByIds)).collect(Collectors.toSet());
            Set<PluginInstallConfiguration.Plugin> stillInstalledFromPluginYaml = confWithInstalledPlugins.stream().flatMap(conf -> conf.getPlugins().stream()).filter(plugin -> {
                try {
                    return installedByIds.contains(plugin.getId());
                } catch (InvalidBundleException e) {
                    // Cannot happen at this point. Bundle already validated
                    return false;
                }
            }).collect(Collectors.toSet());
            Set<String> stillInstalledFromPluginYamlIds = stillInstalledFromPluginYaml.stream().map(plugin -> {
                try {
                    return plugin.getId();
                } catch (InvalidBundleException e) {
                    // Cannot happen at this point. Bundle already validated
                    return null;
                }
            }).filter(Objects::nonNull).collect(Collectors.toSet());

            // For those still installed plugins, get the potential repositories. As the repository configuration might be in a plugins.yaml whose plugins are not more installed, we need to check all configurations
            Set<String> repoIds = stillInstalledFromPluginYaml.stream().filter(plugin -> StringUtils.isNotBlank(plugin.getRepositoryId())).map(PluginInstallConfiguration.Plugin::getRepositoryId).collect(Collectors.toSet());
            Set<PluginInstallConfiguration.Repository> repoForInstalledPlugins = currentBundle.getPluginConfigurations().stream().flatMap(config -> config.getRepositories().stream()).filter(repository -> {
                try {
                    return repoIds.contains(repository.getId());
                } catch (InvalidBundleException e) {
                    // Cannot happen at this point. Bundle already validated
                    return false;
                }
            }).collect(Collectors.toSet());

            // For those still installed plugins or their repositories, get the credentials. As the credentials might be in a plugins.yaml whose plugins are not more installed, we need to check all configurations
            Set<String> credIds = new HashSet<>();
            credIds.addAll(stillInstalledFromPluginYaml.stream().filter(plugin -> StringUtils.isNotBlank(plugin.getCredentialsId())).map(PluginInstallConfiguration.Plugin::getCredentialsId).collect(Collectors.toSet()));
            credIds.addAll(repoForInstalledPlugins.stream().filter(repo -> StringUtils.isNotBlank(repo.getCredentialsId())).map(PluginInstallConfiguration.Repository::getCredentialsId).collect(Collectors.toSet()));
            Set<PluginInstallConfiguration.Credential> credForInstalledPlugins = currentBundle.getPluginConfigurations().stream().flatMap(conf -> conf.getCredentials().stream()).filter(credential -> {
                try {
                    return credIds.contains(credential.getId());
                } catch (InvalidBundleException e) {
                    // Cannot happen at this point. Bundle already validated
                    return false;
                }
            }).collect(Collectors.toSet());

            // Next, those installed plugins that weren't installed using the bundle (manually or as a dependency).
            // Best effort: We cannot know if they were installed uploading the hpi file or through the UC, so we will suppose the Plugin Manager (UC)
            // Note: UC means either CAP plugins, or non CAP plugins from a plugin catalog or a non CAP plugin not in the plugin catalog. In all cases, the configuration is the same (just the id)
            Set<String> installedManually = installedPlugins.stream().filter(pluginWrapper -> !stillInstalledFromPluginYamlIds.contains(pluginWrapper.getShortName())).map(PluginWrapper::getShortName).collect(Collectors.toSet());
            Map<String, EnvelopePlugin> fromEnvelope = CloudBeesAssurance.get().getBeekeeper().getEnvelope().getPlugins();
            Set<PluginInstallConfiguration.Plugin> installedManuallyConfig = installedManually.stream().filter(pluginId -> {
                // If bootstrap, no need to have it there
                if (fromEnvelope.containsKey(pluginId) && fromEnvelope.get(pluginId).getScope().equals(Scope.BOOTSTRAP)) {
                    return false;
                }

                // If it is a dependency, no need to have it there
                if (allDependencies.contains(pluginId)) {
                    return false;
                }

                return true;
            }).map(PluginInstallConfiguration.Plugin::fromUC).collect(Collectors.toSet());

            List<PluginInstallConfiguration.Plugin> finalList = new ArrayList<>();
            finalList.addAll(stillInstalledFromPluginYaml);
            finalList.addAll(installedManuallyConfig);

            try {
                return "# Those plugins manually installed (not using a CasC bundle) might not be installable using the exported CasC bundle if they were uploaded instead of installed through the Plugin Manager\n" +
                       PluginInstallConfiguration.from(finalList, new ArrayList<>(repoForInstalledPlugins), new ArrayList<>(credForInstalledPlugins)).toYaml();
            } catch (InvalidBundleException | IOException e) {
                LOG.log(Level.WARNING, "Plugins could not be exported. Returning an empty export", e);
                return "";
            }
        }

        private String exportForApiVersion1() {
            List<String> plugins = new ArrayList<>();

            // get the list of installed plugins
            List<PluginWrapper> installedPlugins = Jenkins.get().getPluginManager().getPlugins();
            for (PluginWrapper p : installedPlugins) {
                plugins.add(p.getShortName());
            }
            return toYamlPlugins(plugins);

        }

        @NonNull
        @Override
        public String getDescription() {
            return "Plugins to install in the instance";
        }

        @Override
        public String getSection() {
            return "plugins";
        }

        private String toYamlPlugins(@Nonnull List<String> plugins) {
            plugins.sort(String.CASE_INSENSITIVE_ORDER);
            List<Map<String, String>> list = plugins.stream().map(p -> Collections.singletonMap("id", p)).collect(Collectors.toList());
            Map<String, List<Map<String, String>>> obj = Collections.singletonMap("plugins", list);

            DumperOptions options = new DumperOptions();
            options.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);
            options.setIndent(2);
            options.setPrettyFlow(true);
            Yaml yaml = YamlClientUtils.Builder.create().setDumperOptions(options).build();
            return yaml.dump(obj);
        }
    }

    /**
     * Exporter of the rbac.yaml file as text.
     */
    @SuppressRestrictedWarnings(value = {GlobalRbac.class})
    @Extension(ordinal = 2)
    public static final class GlobalRbacExporter extends BundleExporter {
        @NonNull
        @Override
        public String getYamlFile() {
            return "rbac.yaml";
        }

        @Override
        @CheckForNull
        public String getExport() {
            GlobalRbac rbac = new GlobalRbac(Jenkins.get());
            Map<String, Object> yaml = rbac.toYaml();
            if (!yaml.isEmpty()) {
                DumperOptions options = new DumperOptions();
                options.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);
                Yaml output = YamlClientUtils.Builder.create().setDumperOptions(options).build();
                StringWriter writer = new StringWriter();
                output.dump(yaml, writer);
                return writer.toString();
            } else {
                LOG.log(Level.FINE, "There is no global role or group to export.");
                return "";
            }
        }

        @NonNull
        @Override
        public String getDescription() {
            return "The global groups and roles in the instance";
        }

        @Override
        public String getSection() {
            return "rbac";
        }
    }

    /**
     * Exporter the items.yaml file as text.
     */
    @SuppressRestrictedWarnings(value = {Items.class})
    @Extension(ordinal = 1)
    public static final class ItemsExporter extends BundleExporter {
        @NonNull
        @Override
        public String getYamlFile() {
            return "items.yaml";
        }

        @Override
        @CheckForNull
        public String getExport() {
            Items items = new Items(Jenkins.get());
            Map<String, Object> yaml = items.toYaml();

            if (!yaml.isEmpty()) {
                DumperOptions options = new DumperOptions();
                options.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);
                Yaml output = YamlClientUtils.Builder.create().setDumperOptions(options).build();
                StringWriter writer = new StringWriter();
                output.dump(yaml, writer);
                return writer.toString();
            } else {
                LOG.log(Level.FINE, "There is no folder to export.");
                return "";
            }

        }

        @NonNull
        @Override
        public String getDescription() {
            return "The items to create in the instance";
        }

        @Override
        public String getSection() {
            return "items";
        }
    }

    protected String getInstanceName() {
        if (StringUtils.isNotBlank(System.getProperty("MASTER_NAME"))) {
            return System.getProperty("MASTER_NAME").trim();
        } else if (StringUtils.isNotBlank(System.getProperty("HOSTNAME"))) {
            return System.getProperty("HOSTNAME").trim();
        } else {
            return "jenkins";
        }
    }

}
