package com.cloudbees.opscenter.client.casc;

import com.cloudbees.jenkins.plugins.assurance.CloudBeesAssurance;
import com.cloudbees.jenkins.plugins.assurance.model.Beekeeper;
import com.cloudbees.jenkins.plugins.assurance.remote.BeekeeperRemote;
import com.cloudbees.jenkins.plugins.assurance.remote.Status;
import com.cloudbees.jenkins.plugins.assurance.remote.extensionparser.Configuration;
import com.cloudbees.jenkins.plugins.assurance.remote.extensionparser.ParsedEnvelopeExtension;
import com.cloudbees.jenkins.plugins.assurance.remote.extensionparser.PluginConfiguration;
import com.cloudbees.jenkins.plugins.casc.items.Items;
import com.cloudbees.jenkins.plugins.casc.rbac.GlobalRbac;
import com.cloudbees.opscenter.client.casc.visualization.BundleVisualizationLink;
import edu.umd.cs.findbugs.annotations.CheckForNull;
import edu.umd.cs.findbugs.annotations.NonNull;
import hudson.Extension;
import hudson.ExtensionList;
import hudson.ExtensionPoint;
import hudson.PluginWrapper;
import jenkins.model.Jenkins;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang.StringUtils;
import org.kohsuke.accmod.Restricted;
import org.kohsuke.accmod.restrictions.NoExternalUse;
import org.kohsuke.accmod.restrictions.suppressions.SuppressRestrictedWarnings;
import org.yaml.snakeyaml.DumperOptions;
import org.yaml.snakeyaml.Yaml;
import org.yaml.snakeyaml.constructor.SafeConstructor;
import org.yaml.snakeyaml.representer.Representer;

import javax.annotation.Nonnull;
import java.io.IOException;
import java.io.InputStream;
import java.io.StringWriter;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Collectors;

/**
 * Exporter for each CasC bundle file and section.
 */
@Restricted(NoExternalUse.class)
public abstract class BundleExporter implements ExtensionPoint {

    private static final Logger LOG = Logger.getLogger(BundleExporter.class.getName());

    /**
     * @return true if the RootAction is enabled so it can be displayed in UI
     */
    public boolean enabled() {
        return true;
    }

    /**
     * @return the yaml file this extension is exporting
     */
    @NonNull
    public abstract String getYamlFile();

    /**
     * @return the exported file as a String or null
     */
    @CheckForNull
    public abstract String getExport();

    /**
     * @return Description in the UI
     */
    @NonNull
    public abstract String getDescription();

    /**
     * @return section where to add the yaml file in the descriptor
     */
    @CheckForNull
    public abstract String getSection();

    /**
     * Return the exporter for a concrete yaml file
     * @param yamlFile the yaml file to export
     * @return The exporter or null if that exporter does not exist
     */
    @CheckForNull
    public static BundleExporter forYamlFile(@NonNull String yamlFile) {
        return ExtensionList.lookup(BundleExporter.class).stream().filter(exporter -> exporter.getYamlFile().equals(yamlFile) && exporter.enabled()).findFirst().orElse(null);
    }

    public static List<BundleExporter> all() {
        return ExtensionList.lookup(BundleExporter.class).stream().filter(exporter -> exporter.enabled()).collect(Collectors.toList());
    }


    /**
     * Exporter of the bundle.yaml file.
     */
    @Extension(ordinal = 6)
    public static final class DescriptorExporter extends BundleExporter {

        @NonNull
        @Override
        public String getYamlFile() {
            return "bundle.yaml";
        }

        @Override
        @CheckForNull
        public String getExport() {
            return descriptorFromTemplate(getInstanceName(), "Autogenerated bundle descriptor");
        }

        @NonNull
        @Override
        public String getDescription() {
            return "The bundle descriptor";
        }

        @Override
        public String getSection() {
            return null;
        }

        private String descriptorFromTemplate(@CheckForNull String bundleID, String description) {
            try (InputStream in = BundleExporter.class.getResourceAsStream("bundle-descriptor.yaml")){
                String bundle = IOUtils.toString(in, StandardCharsets.UTF_8);
                for (String section : getSections()) {
                    bundle = bundle.concat(String.format("%s:%n", section));
                    for(BundleExporter exporter : forSection(section)) {
                        bundle = bundle.concat(String.format("  - \"%s\"%n", exporter.getYamlFile()));
                    }
                }
                return bundle.replace("%BUNDLE_ID%", bundleID != null ? bundleID : "jenkins").replace("%DESCRIPTION%", description);
            } catch (IOException e) {
                LOG.log(Level.WARNING, "Cannot read bundle descriptor template to generate an export response", e);
                return null;
            }
        }

        private List<BundleExporter> forSection(String section) {
            return BundleExporter.all().stream().filter(exporter -> exporter.getSection() != null && exporter.getSection().equals(section)).collect(Collectors.toList());
        }

        private List<String> getSections() {
            return BundleExporter.all().stream().filter(exporter -> exporter.getSection() != null).map(BundleExporter::getSection).collect(Collectors.toList());
        }

    }

    /**
     * Exporter of the plugins.yaml file as text.
     */
    @Extension(ordinal = 4)
    public static final class PluginsExporter extends BundleExporter {

        @NonNull
        @Override
        public String getYamlFile() {
            return "plugins.yaml";
        }

        /**
         * Generates the plugins.yaml file content.
         * <p>
         * The plugins list will contain all plugins installed in the controller, if and only if CAP is enabled.
         * It returns a warning message otherwise.
         */
        @SuppressRestrictedWarnings(value = {CloudBeesAssurance.class, ParsedEnvelopeExtension.class, Beekeeper.class,
                Configuration.class, PluginConfiguration.class})
        @Override
        @CheckForNull
        public String getExport() {
            List<String> plugins = new ArrayList<>();
            // check if the CAP is enabled
            Status status = BeekeeperRemote.get().getStatus();
            if (!status.isCap()) {
                String msg = "Cannot export plugins because CAP is not enabled";
                LOG.log(Level.WARNING, msg);
                return msg;
            }
            // get the list of installed plugins
            List<PluginWrapper> installedPlugins = Jenkins.get().getPluginManager().getPlugins();
            for (PluginWrapper p : installedPlugins) {
                plugins.add(p.getShortName());
            }
            return toYamlPlugins(plugins);
        }

        @NonNull
        @Override
        public String getDescription() {
            return "Plugins to install in the controller";
        }

        @Override
        public String getSection() {
            return "plugins";
        }

        private String toYamlPlugins(@Nonnull List<String> plugins) {
            plugins.sort(String.CASE_INSENSITIVE_ORDER);
            List<Map<String, String>> list = plugins.stream().map(p -> {return Collections.singletonMap("id", p);}).collect(Collectors.toList());
            Map<String, List<Map<String, String>>> obj = Collections.singletonMap("plugins", list);

            DumperOptions options = new DumperOptions();
            options.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);
            options.setIndent(2);
            options.setPrettyFlow(true);
            Yaml yaml = new Yaml(new SafeConstructor(), new Representer(), options);
            return yaml.dump(obj).chars().filter(ch -> ('{'!=ch && '}' != ch)).collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString();
        }
    }

    /**
     * Exporter of the rbac.yaml file as text.
     */
    @SuppressRestrictedWarnings(value = {GlobalRbac.class})
    @Extension(ordinal = 2)
    public static final class GlobalRbacExporter extends BundleExporter {
        @NonNull
        @Override
        public String getYamlFile() {
            return "rbac.yaml";
        }

        @Override
        @CheckForNull
        public String getExport() {
            GlobalRbac rbac = new GlobalRbac(Jenkins.get());
            Map<String, Object> yaml = rbac.toYaml();
            if (!yaml.isEmpty()) {
                DumperOptions options = new DumperOptions();
                options.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);
                Yaml output = new Yaml(new SafeConstructor(), new Representer(), options);
                StringWriter writer = new StringWriter();
                output.dump(yaml, writer);
                return writer.toString();
            } else {
                LOG.log(Level.FINE, "There is no global role or group to export.");
                return "";
            }
        }

        @NonNull
        @Override
        public String getDescription() {
            return "The global groups and roles in the controller";
        }

        @Override
        public String getSection() {
            return "rbac";
        }
    }

    /**
     * Exporter the items.yaml file as text.
     */
    @SuppressRestrictedWarnings(value = {Items.class})
    @Extension(ordinal = 1)
    public static final class ItemsExporter extends BundleExporter {
        @NonNull
        @Override
        public String getYamlFile() {
            return "items.yaml";
        }

        @Override
        @CheckForNull
        public String getExport() {
            Items items = new Items(Jenkins.get());
            Map<String, Object> yaml = items.toYaml();

            if (!yaml.isEmpty()) {
                DumperOptions options = new DumperOptions();
                options.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);
                Yaml output = new Yaml(new SafeConstructor(), new Representer(), options);
                StringWriter writer = new StringWriter();
                output.dump(yaml, writer);
                return writer.toString();
            } else {
                LOG.log(Level.FINE, "There is no folder to export.");
                return "";
            }

        }

        @NonNull
        @Override
        public String getDescription() {
            return "The items to create in the controller";
        }

        @Override
        public String getSection() {
            return "items";
        }
    }

    protected String getInstanceName() {
        if (StringUtils.isNotBlank(System.getProperty("MASTER_NAME"))) {
            return System.getProperty("MASTER_NAME").trim();
        } else if (StringUtils.isNotBlank(System.getProperty("HOSTNAME"))) {
            return System.getProperty("HOSTNAME").trim();
        } else {
            return "jenkins";
        }
    }

}
